package com.neocoretechs.bigsack.keyvaluepages;

import java.io.IOException;

import com.neocoretechs.bigsack.btree.BTNode;
import com.neocoretechs.bigsack.btree.BTreeNavigator;
import com.neocoretechs.bigsack.btree.StructureCallBackListener;
import com.neocoretechs.bigsack.io.Optr;
import com.neocoretechs.bigsack.io.pooled.BlockAccessIndex;
import com.neocoretechs.bigsack.io.pooled.GlobalDBIO;
/**
 * Interface to the Main implementation of the chosen K/V store, such as HMap or BTree.
 * @author Jonathan Groff Copyright (C) NeoCoreTechs 2021
 *
 */
public interface KeyValueMainInterface {

	/**
	 * Gets a page from the pool and sets currentPage and this.root
	 * to that value, then calls getRootNode.
	 * This method attempts to link the {@link BlockAccessIndex} to the {@link KeyPageInterface} to 'this'
	 * then link the {@link NodeInterface} generated by {@link KeyValueMainInterface}
	 * @throws IOException
	 */
	RootKeyPageInterface createRootNode() throws IOException;

	/**
	 * When we create KeyValueMain, a call to getRootNode in KeyValueMain will either
	 * return the root node, or call createRootNode in KeyValueMain, which will call back here.<p/>
	 * We acquire our BlockAccessIndex, which is rolled into our KeyPageInterface which communicates with our NodeInterface.
	 * @return 
	 * @throws IOException
	 */
	RootKeyPageInterface createRootNode(NodeInterface btNode) throws IOException;

	/**
	 * Used by factory methods upon node creation. Intent is node setup.
	 * {@link BlockAccessIndex} overloaded static methods.
	 * @param tnode The new NodeInterface
	 * @throws IOException
	 */
	KeyPageInterface createNode(NodeInterface tnode) throws IOException;
	
	/**
	 * Retrieve the page that contains key/value instances and use the data from that page to
	 * set it up. Similar to createNode but used for existing pages.
	 * @param tNode the node to be set up.
	 * @param pageId the page to be retrieved
	 * @throws IOException
	 */
	KeyPageInterface getNode(NodeInterface tNode, long pageId) throws IOException;

	Comparable getKey(Optr keyLoc) throws IOException;
	
	Object getValue(Optr valueLoc) throws IOException;
	/**
	 * Returns number of table scanned keys, sets numKeys field
	 * TODO: Alternate more efficient implementation that counts keys on pages
	 * This method scans all keys, thus verifying the structure.
	 * @throws IOException
	 */
	long count() throws IOException;

	/**
	 * Determines if k/v store is empty by examining the root for the presence of any keys
	 * @return
	 */
	boolean isEmpty();

	/**
	* currentPage and currentIndex set by this seeker of a target object value.
	* The only physically possible way is an iteration through the entire collection until found or end.
	* @param targetObject The Object value to seek.
	* @return data Object if found. null otherwise.
	* @exception IOException if read failure
	*/
	Object seekObject(Object targetObject) throws IOException;

	/**
	* Seek the key, if we dont find it, leave the k/v store at it position closest greater than element.
	* If we do find it return true in atKey of result and leave at found key.
	* Calls search, which calls clearStack, repositionStack and setCurrent.
	* @param targetKey The Comparable key to seek
	* @return search result with key data
	* @exception IOException if read failure
	*/
	KeySearchResult seekKey(Comparable targetKey) throws IOException;

	/**
	 * Called back from delete in NodeInterface to remove persistent data prior to in-memory update where the
	 * references would be lost.
	 * @param optr The pointer with virtual block and offset
	 * @param o The object that was previously present at that location
	 * @throws IOException
	 */
	void delete(Optr optr, Object o) throws IOException;

	/**
	 * Add to deep store, Set operation.
	 * @param key
	 * @return
	 * @throws IOException
	 */
	int add(Comparable key) throws IOException;

	/**
	 * Add an object and/or key to the deep store. Traverse the KeyValueMainInterface for the insertion point and insert. Map operation.
	 * @param key
	 * @param object
	 * @return 0 for key absent, 1 for key exists
	 * @throws IOException
	 */
	int add(Comparable key, Object value) throws IOException;

	/**
	 * Sets up the return KeyPageInterface similar to 'reposition' but this public method initializes root node etc.
	 * The purpose is to provide a detached locate method to do intermediate key checks before insert, then use
	 * 'add' with the KeyPageInterface in the TreeSearchResult returned from this method.
	 * If the TreeSearchResult.insertPoint is > 0 then insertPoint - 1 points to the key that immediately
	 * precedes the target key.
	 * @param node
	 * @param key
	 * @return
	 * @throws IOException
	 */
	KeySearchResult locate(Comparable key) throws IOException;

	/**
	* Remove key/data object.
	* Deletion from a B-tree is more complicated than insertion, because we can delete a key from any node, not 
	* just a leaf, and when we delete a key from an internal node, we will have to rearrange the nodes children.
	* As in insertion, we must make sure the deletion doesnt violate the B-tree properties. 
	* Just as we had to ensure that a node didnt get too big due to insertion, we must ensure that a node 
	* doesnt get too small during deletion (except that the root is allowed to have fewer than the minimum number t-1 of keys). 
	* Just as a simple insertion algorithm might have to back up if a node on the path to where the key was to be inserted was full, 
	* a simple approach to deletion might have to back up if a node (other than the root) along the path to where the key is to be 
	* deleted has the minimum number of keys.
	* The deletion procedure deletes the key k from the subtree rooted at x. 
	* This procedure guarantees that whenever it calls itself recursively on a node x, the number of keys in x is at least the minimum degree T.
	* Note that this condition requires one more key than the minimum required by the usual B-tree conditions, 
	* so that sometimes a key may have to be moved into a child node before recursion descends to that child. 
	* This strengthened condition allows us to delete a key from the tree in one downward pass without having to back up
	* (with one exception, to be explained). You should interpret the following specification for deletion from a B-tree 
	* with the understanding that if the root node x ever becomes an internal node having no keys 
	* (this situation can occur when we delete x, and x only child x.c1 becomes the new root of the tree), 
	* we decrease the height of the tree by one and preserve the property that the root of the tree contains at least one key. 
	* (unless the tree is empty).
	* Various cases of deleting keys from a B-tree:
	* 1. If the key k is in node x and x is a leaf, delete the key k from x.
	* 2. If the key k is in node x and x is an internal node, do the following:
	* a) If the child y that precedes k in node x has at least t keys, then find the predecessor k0 of k in the sub-tree rooted at y. 
	* Recursively delete k0, and replace k by k0 in x. (We can find k0 and delete it in a single downward pass.)
	* b) If y has fewer than t keys, then, symmetrically, examine the child z that follows k in node x. If z has at least t keys, 
	* then find the successor k0 of k in the subtree rooted at z. Recursively delete k0, and replace k by k0 in x. 
	* (We can find k0 and delete it in a single downward pass.)
	* c) Otherwise, if both y and z have only t-1 keys, merge k and all of z into y, so that x loses both k and the pointer to z, and y 
	* now contains 2t-1 keys. Then free z and recursively delete k from y.
	* 3. If the key k is not present in internal node x, determine the root x.c(i) of the appropriate subtree that must contain k, 
	* if k is in the tree at all. If x.c(i) has only t-1 keys, execute step 3a or 3b as necessary to guarantee that we descend to a 
	* node containing at least t keys. Then finish by recursing on the appropriate child of x.
	* a) If x.c(i) has only t-1 keys but has an immediate sibling with at least t keys, give x.c(i) an extra key by moving a key 
	* from x down into x.c(i), moving a key from x.c(i) immediate left or right sibling up into x, and moving the appropriate 
	* child pointer from the sibling into x.c(i).
	* b) If x.c(i) and both of x.c(i) immediate siblings have t-1 keys, merge x.c(i) with one sibling, which involves moving a key 
	* from x down into the new merged node to become the median key for that node.
	* Since most of the keys in a B-tree are in the leaves, deletion operations are most often used to delete keys from leaves. 
	* The recursive delete procedure then acts in one downward pass through the tree, without having to back up. 
	* When deleting a key in an internal node, however, the procedure makes a downward pass through the tree but may have to 
	* return to the node from which the key was deleted to replace the key with its predecessor or successor.
	* The KeyPageInterface contains most of the functionality and the following methods are unique to the deletion process:
	* 1) remove
	* 2) removeFromNonLeaf
	* 3) getPred
	* 4) getSucc
	* 5) borrowFromPrev
	* 6) borrowFromNext
	* 7) merge
	* @param newKey The key to delete
	* @return 0 if ok, <> 0 if error
	* @exception IOException if seek or write failure
	*/
	int delete(Comparable newKey) throws IOException;

	/**
	 * Rewind current position to beginning of tree. Sets up stack with pages and indexes
	 * such that traversal can take place. Remember to clear stack after these operations.
	 * @exception IOException If read fails
	 */
	KeyValue rewind() throws IOException;

	/**
	 * Set current position to end of tree.Sets up stack with pages and indexes
	 * such that traversal can take place. Remember to clear stack after these operations. 
	 * @return 
	 * @exception IOException If read fails
	 */
	KeyValue toEnd() throws IOException;

	/**
	* Seek to location of next key in k/v store. Set current key and current object.
	* Attempt to advance the child index at the current node. If it advances beyond numKeys, a pop
	* is necessary to get us to the previous level. We repeat the process a that level, advancing index
	* and checking, and again repeating pop.
	* If we get to a currentIndex advanced to the proper index, we know we are not at a leaf since we
	* popped the node as a parent, so we know there is a subtree somewhere, so descend the subtree 
	* of the first key to the left that has a child until we reach a terminal 'leaf' node.
	* We are finished when we are at the root and can no longer traverse right. this is because we popped all the way up,
	* and there are no more subtrees to traverse.
	* Note that we dont deal with keys at all here, just child pointers.
	* @return 0 if ok, != 0 if error
	* @exception IOException If read fails
	*/
	TraversalStackElement gotoNextKey(TraversalStackElement tse) throws IOException;

	/**
	* Go to location of previous key in k/v store
	* @return 0 if ok, <>0 if error
	* @exception IOException If read fails
	*/
	TraversalStackElement gotoPrevKey(TraversalStackElement tse) throws IOException;

	/**
	 * Utilize reposition to locate key. Set currentPage, currentIndex, currentKey, and currentChild.
	 * deallocOutstanding is called before exit.
	 * @param targetKey The key to position to in KeyValueMainInterface
	 * @return TreeSearchResult containing page, insertion index, atKey = true for key found
	 * @throws IOException
	 */
	KeySearchResult search(Comparable targetKey) throws IOException;

	/**
	* Internal routine to clear references on stack. Just does stack.clear
	*/
	void clearStack();

	GlobalDBIO getIO();

	void setIO(GlobalDBIO sdbio);
	/**
	 * Return the array of root pages, or in the case such as a BTree where there is but one
	 * it will reside in element 0
	 * @return
	 */
	RootKeyPageInterface[] getRoot();

	/**
	 * Walk the tree calling back the method to deliver structure data to some process
	 * such as graphical display.
	 * @throws IOException
	 */
	void traverseStructure(StructureCallBackListener listener, KeyPageInterface node, long parent, int level)
			throws IOException;

}